(* 1 Lexical grammar *)
(* 1.1 Lexical elements *)
token
    = keyword
    | identifier
    | constant
    | string-literal
    | punctuator;

preprocessing-token
    = header-name
    | identifier
    | pp-number
    | character-constant
    | string-literal
    | punctuator
    | ? each universal-character-name that cannot be one of the above ?
    | ? each non-white-space character that cannot be one of the above ?;

(* 1.2 Keywords *)
keyword
    = 'alignas'
    | 'alignof'
    | 'auto'
    | 'bool'
    | 'break'
    | 'case'
    | 'char'
    | 'const'
    | 'constexpr'
    | 'continue'
    | 'default'
    | 'do'
    | 'double'
    | 'else'
    | 'enum'
    | 'extern'
    | 'false'
    | 'float'
    | 'for'
    | 'goto'
    | 'if'
    | 'inline'
    | 'int'
    | 'long'
    | 'nullptr'
    | 'register'
    | 'restrict'
    | 'return'
    | 'short'
    | 'signed'
    | 'sizeof'
    | 'static'
    | 'static_assert'
    | 'struct'
    | 'switch'
    | 'thread_local'
    | 'true'
    | 'typedef'
    | 'typeof'
    | 'typeof_unqual'
    | 'union'
    | 'unsigned'
    | 'void'
    | 'volatile'
    | 'while'
    | '_Atomic'
    | '_BigInt'
    | '_Complex'
    | '_Decimal128'
    | '_Decimal32'
    | '_Decimal64'
    | '_Generic'
    | '_Imaginary'
    | "_Noreturn";

(* 1.3 Identifiers *)
identifier
    = identifier-start
    | identifier;

identifier-start
    = nondigit
    | XID_Start-character
    | universal-character-name-of-class-XID_Start;

identifier-continue
    = digit
    | nondigit
    | XID_Continue-character
    | universal-character-name-of-class-XID_Continue;

nondigit
    = '_'
    | 'a'
    | 'b'
    | 'c'
    | 'd'
    | 'e'
    | 'f'
    | 'g'
    | 'h'
    | 'i'
    | 'j'
    | 'k'
    | 'l'
    | 'm'
    | 'n'
    | 'o'
    | 'p'
    | 'q'
    | 'r'
    | 's'
    | 't'
    | 'u'
    | 'v'
    | 'w'
    | 'x'
    | 'y'
    | 'z'
    | 'A'
    | 'B'
    | 'C'
    | 'D'
    | 'E'
    | 'F'
    | 'G'
    | 'H'
    | 'I'
    | 'J'
    | 'K'
    | 'L'
    | 'M'
    | 'N'
    | 'O'
    | 'P'
    | 'Q'
    | 'R'
    | 'S'
    | 'T'
    | 'U'
    | 'V'
    | 'W'
    | 'X'
    | 'Y'
    | 'Z';

digit
    = '0'
    | '1'
    | '2'
    | '3'
    | '4'
    | '5'
    | '6'
    | '7'
    | '8'
    | '9';

(* 1.4 Universal character names *)
universal-character-name
    = '\u', hex-quad
    | '\U', hex-quad, hex-quad;

hex-quad
    = hexadecimal-digit, hexadecimal-digit, hexadecimal-digit, hexadecimal-digit;

(* 1.5 Constants *)
constant
    = integer-constant
    | floating-constant
    | enumeration-constant
    | character-constant
    | predefined-constant;

integer-constant
    = decimal-constant, [ integer-constant ]
    | octal-constant, [ integer-constant ]
    | hexadecimal-constant, [ integer-constant ]
    | binary-constant, [ integer-constant ];

decimal-constant
    = nonzero-digit
    | decimal-constant, [ "'" ], digit;

octal-constant
    = '0'
    | octal-constant, [ "'" ], octal-digit;

hexadecimal-constant
    = hexadecimal-prefix, hexadecimal-digit-sequence;

binary-constant
    = binary-prefix, binary-digit
    | binary-constant, [ "'" ], binary-digit;

hexadecimal-prefix
    = '0x'
    | '0X';

binary-prefix
    = '0b'
    | '0B';

nonzero-digit
    = '1'
    | '2'
    | '3'
    | '4'
    | '5'
    | '6'
    | '7'
    | '8'
    | '9';

octal-digit
    = '0'
    | '1'
    | '2'
    | '3'
    | '4'
    | '5'
    | '6'
    | '7';

hexadecimal-digit-sequence
    = hexadecimal-digit
    | hexadecimal-digit-sequence, [ "'" ], hexadecimal-digit;

hexadecimal-digit
    = '0'
    | '1'
    | '2'
    | '3'
    | '4'
    | '5'
    | '6'
    | '7'
    | '8'
    | '9'
    | 'a'
    | 'b'
    | 'c'
    | 'd'
    | 'e'
    | 'f'
    | 'A'
    | 'B'
    | 'C'
    | 'D'
    | 'E'
    | 'F';

binary-digit
    = '0'
    | '1';

integer-suffix
    = unsigned-suffix, [ long-suffix ]
    | unsigned-suffix, long-long-suffix
    | unsigned-suffix, bit-precise-int-suffix
    | long-suffix, [ unsigned-suffix ]
    | long-long-suffix, [ unsigned-suffix ]
    | bit-precise-int-suffix, [ unsigned-suffix ];

bit-precise-int-suffix
    = 'wb'
    | 'WB';

unsigned-suffix
    = 'u'
    | 'U';

long-suffix
    = 'l'
    | 'L';

long-long-suffix
    = 'll'
    | 'LL';

floating-constant
    = decimal-floating-constant
    | hexadecimal-floating-constant;

decimal-floating-constant
    = fractional-constant, [ exponent-part ], [ floating-suffix ]
    | digit-sequence, exponent-part, [ floating-suffix ];

hexadecimal-floating-constant
    = hexadecimal-prefix, hexadecimal-fractional-constant, binary-exponent-part, [ floating-suffix ]
    | hexadecimal-prefix, hexadecimal-digit-sequence, binary-exponent-part, [ floating-suffix ];

fractional-constant
    = [ digit-sequence ], '.', digit-sequence
    | digit-sequence, '.';

exponent-part
    = 'e', [ sign ], digit-sequence
    | 'E', [ sign ], digit-sequence;

sign
    = '+' 
    | '-';

digit-sequence
    = digit
    | digit-sequence, [ "'" ], digit;

hexadecimal-fractional-constant
    = [ hexadecimal-digit-sequence ], '.', hexadecimal-digit-sequence
    | hexadecimal-digit-sequence, '.';

binary-exponent-part
    = 'p', [ sign ], digit-sequence
    | 'P', [ sign ], digit-sequence;

floating-suffix
    = 'f'
    | 'l'
    | 'F'
    | 'L'
    | 'df'
    | 'dd'
    | 'dl'
    | 'DF'
    | 'DD'
    | 'DL';

enumeration-constant
    = identifier;

character-constant
    = [ encoding-prefix ], "'", c-char-sequence, "'";

encoding-prefix
    = 'u8'
    | 'u'
    | 'U'
    | 'L';

c-char-sequence
    = c-char
    | c-char-sequence, c-char;

c-char
    = ? any member of the source character set except the single-quote , backslash , or new-line character ?
    | escape-sequence;

escape-sequence
    = simple-escape-sequence
    | octal-escape-sequence
    | hexadecimal-escape-sequence
    | universal-character-name;

simple-escape-sequence
    = "\'"
    | '\"'
    | '\?'
    | '\\'
    | '\a'
    | '\b'
    | '\f'
    | '\n'
    | '\r'
    | '\t'
    | '\v';

octal-escape-sequence
    = '\', octal-digit
    | '\', octal-digit, octal-digit
    | '\', octal-digit, octal-digit, octal-digit;

hexadecimal-escape-sequence
    = '\x', hexadecimal-digit
    | hexadecimal-escape-sequence, hexadecimal-digit;

predefined-constant
    = 'false'
    | 'true'
    | 'nullptr';

(* 1.6 String literals *)
string-literal
    = [ encoding-prefix ], '"', [ s-char-sequence ], '"';

s-char-sequence
    = s-char
    | s-char-sequence, s-char;

s-char
    = ? any member of the source character set except the double-quote , backslash , or new-line character ?
    | escape-sequence;

(* 1.7 Punctuators *)
punctuator
    = '['
    | ']'
    | '('
    | ')'
    | '{'
    | '}'
    | '.'
    | '->'
    | '++'
    | '--'
    | '&'
    | '*'
    | '+'
    | '-'
    | '~'
    | '!'
    | '/'
    | '%'
    | '<<'
    | '>>'
    | '<'
    | '>'
    | '<='
    | '>='
    | '=='
    | '!='
    | '^'
    | '|'
    | '&&'
    | '||'
    | '?'
    | ':'
    | '::'
    | ';'
    | '...'
    | '='
    | '*='
    | '/='
    | '%='
    | '+='
    | '-='
    | '<<='
    | '>>='
    | '&='
    | '^='
    | '|='
    | ','
    | '#'
    | '##'
    | '<:'
    | ':>'
    | '<%'
    | '%>'
    | '%:'
    | '%:%:';

(* 1.8 Header names *)
header-name
    = '<', h-char-sequence, '>'
    | '"', q-char-sequence, '"';

h-char-sequence
    = h-char
    | h-char-sequence, h-char;

h-char
    = ? any member of the source character set except the new-line character and ?;

q-char-sequence
    = q-char
    | q-char-sequence, q-char;

q-char
    = ? any member of the source character set except the new-line character and " ?;

(* 1.9 Preprocessing numbers *)
pp-number
    = digit
    | '.', digit
    | pp-number, identifier-continue
    | pp-number, "'", digit
    | pp-number, "'", nondigit
    | pp-number, 'e', sign
    | pp-number, 'E', sign
    | pp-number, 'p', sign
    | pp-number, 'P', sign
    | pp-number, '.';

(* 2 Phrase structure grammar *)
(* 2.1 Expressions *)
primary-expression
    = identifier
    | constant
    | string-literal
    | '(', expression, ')'
    | generic-selection;

generic-selection
    = '_Generic', '(', assignment-expression, ',', generic-assoc-list, ')';

generic-assoc-list
    = generic-association
    | generic-assoc-list, ',', generic-association;

generic-association
    = type-name, ':', assignment-expression
    | 'default', ':', assignment-expression;

postfix-expression
    = primary-expression
    | postfix-expression, '[', expression, ']'
    | postfix-expression, '(', [ argument-expression-list ], ')'
    | postfix-expression, '.', identifier
    | postfix-expression, '->', identifier
    | postfix-expression, '++'
    | postfix-expression, '--'
    | compound-literal;

argument-expression-list
    = assignment-expression
    | argument-expression-list, ',', assignment-expression;

compound-literal
    = '(', [ storage-class-specifiers ], type-name, ')', braced-initializer;

storage-class-specifiers
    = storage-class-specifier
    | storage-class-specifiers, storage-class-specifier;

unary-expression
    = postfix-expression
    | '++', unary-expression
    | '--', unary-expression
    | unary-operator, cast-expression
    | 'sizeof', unary-expression
    | 'sizeof', '(', type-name, ')'
    | 'alignof', '(', type-name, ')';

unary-operator
    = '&'
    | '*'
    | '+'
    | '-'
    | '~'
    | '!';

cast-expression
    = unary-expression
    | '(', type-name, ')', cast-expression;

multiplicative-expression
    = cast-expression
    | multiplicative-expression, '*', cast-expression
    | multiplicative-expression, '/', cast-expression
    | multiplicative-expression, '%', cast-expression;

additive-expression
    = multiplicative-expression
    | additive-expression, '+', multiplicative-expression
    | additive-expression, '-', multiplicative-expression;

shift-expression
    = additive-expression
    | shift-expression, '<<', additive-expression
    | shift-expression, '>>', additive-expression;

relational-expression
    = shift-expression
    | relational-expression, '<', shift-expression
    | relational-expression, '>', shift-expression
    | relational-expression, '=', shift-expression
    | relational-expression, '=', shift-expression;

equality-expression
    = relational-expression
    | equality-expression, '==', relational-expression
    | equality-expression, '!=', relational-expression;

AND-expression
    = equality-expression
    | AND-expression, '&', equality-expression;

exclusive-OR-expression
    = AND-expression
    | exclusive-OR-expression, '^', AND-expression;

inclusive-OR-expression
    = exclusive-OR-expression
    | inclusive-OR-expression, '|', exclusive-OR-expression;

logical-AND-expression
    = inclusive-OR-expression
    | logical-AND-expression, '&&', inclusive-OR-expression;

logical-OR-expression
    = logical-AND-expression
    | logical-OR-expression, '||', logical-AND-expression;

conditional-expression
    = logical-OR-expression
    | logical-OR-expression, '?', expression, ':', conditional-expression;

assignment-expression
    = conditional-expression
    | unary-expression, assignment-operator, assignment-expression;

assignment-operator
    = '='
    | '*='
    | '/='
    | '%='
    | '+='
    | '-='
    | '<<='
    | '>>='
    | '&='
    | '^='
    | '|=';

expression
    = assignment-expression
    | expression, ',', assignment-expression;

constant-expression
    = conditional-expression;

(* 2.2 Declarations *)
declaration
    = declaration-specifiers, [ init-declarator-list ], ';'
    | attribute-specifier-sequence, declaration-specifiers, init-declarator-list, ';'
    | static_assert-declaration
    | attribute-declaration;

declaration-specifiers
    = declaration-specifier, [ attribute-specifier-sequence ]
    | declaration-specifier, declaration-specifiers;

declaration-specifier
    = storage-class-specifier
    | type-specifier-qualifier
    | function-specifier;

init-declarator-list
    = init-declarator
    | init-declarator-list, ',', init-declarator;

init-declarator
    = declarator
    | declarator, '=', initializer;

attribute-declaration
    = attribute-specifier-sequence, ';';

storage-class-specifier
    = 'auto'
    | 'constexpr'
    | 'extern'
    | 'register'
    | 'static'
    | 'thread_local'
    | 'typedef';

type-specifier
    = 'void'
    | 'char'
    | 'short'
    | 'int'
    | 'long'
    | 'float'
    | 'double'
    | 'signed'
    | 'unsigned'
    | '_BitInt', '(', constant-expression, ')'
    | 'bool'
    | '_Complex'
    | '_Decimal32'
    | '_Decimal64'
    | '_Decimal128'
    | atomic-type-specifier
    | struct-or-union-specifier
    | enum-specifier
    | typedef-name
    | typeof-specifier;

struct-or-union-specifier
    = struct-or-union, [ attribute-specifier-sequence ], [ identifier ], '{', member-declaration-list, '}'
    | struct-or-union, [ attribute-specifier-sequence ], identifier;

struct-or-union
    = 'struct'
    | 'union';

member-declaration-list
    = member-declaration
    | member-declaration-list, member-declaration;

member-declaration
    = [ attribute-specifier-sequence ], specifier-qualifier-list, [ member-declarator-list ], ';'
    | static_assert-declaration;

specifier-qualifier-list
    = type-specifier-qualifier, [ attribute-specifier-sequence ]
    | type-specifier-qualifier, specifier-qualifier-list;

type-specifier-qualifier
    = type-specifier
    | type-qualifier
    | alignment-specifier;

member-declarator-list
    = member-declarator
    | member-declarator-list, ',', member-declarator;

member-declarator
    = declarator
    | [ declarator ], ':', constant-expression;

enum-specifier
    = 'enum', [ attribute-specifier-sequence ], [ identifier ], [ enum-type-specifier ], '{', enumerator-list, [ ',' ], '}'
    | 'enum', identifier, [ enum-type-specifier ];

enumerator-list
    = enumerator
    | enumerator-list, ',', enumerator;

enumerator
    = enumeration-constant, [ attribute-specifier-sequence ]
    | enumeration-constant, [ attribute-specifier-sequence ], '=', constant-expression;

enum-type-specifier
    = ':', specifier-qualifier-list;

atomic-type-specifier
    = '_Atomic', '(', type-name, ')';

typeof-specifier
    = 'typeof', '(', typeof-specifier-argument, ')'
    | 'typeof_unqual', '(', typeof-specifier-argument, ')';

typeof-specifier-argument
    = expression
    | type-name;

type-qualifier
    = 'const'
    | 'restrict'
    | 'volatile'
    | '_Atomic';

function-specifier
    = 'inline'
    | '_Noreturn';

alignment-specifier
    = 'alignas', '(', type-name, ')'
    | 'alignas', '(', constant-expression, ')';

declarator
    = [ pointer ], direct-declarator;

direct-declarator
    = identifier, [ attribute-specifier-sequence ]
    | '(', declarator, ')'
    | array-declarator, [ attribute-specifier-sequence ]
    | function-declarator, [ attribute-specifier-sequence ];

array-declarator
    = direct-declarator, '[', [ type-qualifier-list ], [ assignment-expression ], ']'
    | direct-declarator, '[', 'static', [ type-qualifier-list ], assignment-expression, ']'
    | direct-declarator, '[', type-qualifier-list, 'static', assignment-expression, ']'
    | direct-declarator, '[', [ type-qualifier-list ], '*', ']';

function-declarator
    = direct-declarator, '(', [ parameter-type-list ], ')';

pointer
    = '*', [ attribute-specifier-sequence ], [ type-qualifier-list ]
    | '*', [ attribute-specifier-sequence ], [ type-qualifier-list ], pointer;

type-qualifier-list
    = type-qualifier
    | type-qualifier-list, type-qualifier;

parameter-type-list
    = parameter-list
    | parameter-list, ',', '...'
    | '...';

parameter-list
    = parameter-declaration
    | parameter-list, ',', parameter-declaration;

parameter-declaration
    = [ attribute-specifier-sequence ], declaration-specifiers, declarator
    | [ attribute-specifier-sequence ], declaration-specifiers, [ abstract-declarator ];

type-name
    = specifier-qualifier-list, [ abstract-declarator ];

abstract-declarator
    = pointer
    | [ pointer ], direct-abstract-declarator;

direct-abstract-declarator
    = '(', abstract-declarator, ')'
    | array-abstract-declarator, [ attribute-specifier-sequence ]
    | function-abstract-declarator, [ attribute-specifier-sequence ];

array-abstract-declarator
    = [ direct-abstract-declarator ], '[', [ type-qualifier-list ], [ assignment-expression ], ']'
    | [ direct-abstract-declarator ], '[', 'static', [ type-qualifier-list ], assignment-expression, ']'
    | [ direct-abstract-declarator ], '[', type-qualifier-list, 'static', 'assignment-expression', ']'
    | [ direct-abstract-declarator ], '[', '*', ']';

function-abstract-declarator
    = [ direct-abstract-declarator ], '(', [ parameter-type-list ], ')';

typedef-name
    = identifier;

braced-initializer
    = '{', '}'
    | '{', initializer-list, [ ',' ], '}';

initializer
    = assignment-expression
    | braced-initializer;

initializer-list
    = [ designation ], initializer
    | initializer-list, ',', [ designation ], initializer;

designation
    = designator-list, '=';

designator-list
    = designator
    | designator-list, designator;

designator
    = '[', constant-expression, ']'
    | '.', identifier;

static_assert-declaration
    = 'static_assert', '(', constant-expression, [ ',', string-literal ], ')', ';';

attribute-specifier-sequence
    = [ attribute-specifier-sequence ], attribute-specifier;

attribute-specifier
    = '[', '[', attribute-list, ']', ']';

attribute-list
    = [ attribute ]
    | attribute-list, ',', [ attribute ];

attribute
    = attribute-token, [ attribute-argument-clause ];

attribute-token
    = standard-attribute
    | attribute-prefixed-token;

standard-attribute
    = identifier;

attribute-prefixed-token
    = attribute-prefix, '::', identifier;

attribute-prefix
    = identifier;

attribute-argument-clause
    = '(', [ balanced-token-sequence ], ')';

balanced-token-sequence
    = balanced-token
    | balanced-token-sequence, balanced-token;

balanced-token
    = '(', [ balanced-token-sequence ], ')'
    | '[', [ balanced-token-sequence ], ']'
    | '{', [ balanced-token-sequence ], '}'
    | ? any token other than a parenthesis , a bracket , or a brace ?;

(* 2.3 Statements *)
statement
    = labeled-statement
    | unlabeled-statement;

unlabeled-statement
    = expression-statement
    | [ attribute-specifier-sequence ], primary-block
    | [ attribute-specifier-sequence ], jump-statement;

primary-block
    = compound-statement
    | selection-statement
    | iteration-statement;

secondary-block
    = statement;

label
    = [ attribute-specifier-sequence ], identifier, ':'
    | [ attribute-specifier-sequence ], 'case', constant-expression, ':'
    | [ attribute-specifier-sequence ], 'default', ':';

labeled-statement
    = label, statement;

compound-statement
    = '{', [ block-item-list ], '}';

block-item-list
    = block-item
    | block-item-list, block-item;

block-item
    = declaration
    | unlabeled-statement
    | label;

expression-statement
    = [ expression ], ';'
    | attribute-specifier-sequence, expression, ';';

selection-statement
    = 'if', '(', expression, ')', secondary-block
    | 'if', '(', expression, ')', secondary-block, 'else', secondary-block
    | 'switch', '(', expression, ')', secondary-block;

iteration-statement
    = 'while', '(', expression, ')', secondary-block
    | 'do', secondary-block, 'while', '(', expression, ')', ';'
    | 'for', '(', [ expression ], ';', [ expression ], ';', [ expression ], ')', secondary-block
    | 'for', '(', declaration, [ expression ], ';', [ expression ], ')', secondary-block;

jump-statement
    = 'goto', identifier, ';'
    | 'continue', ';'
    | 'break', ';'
    | 'return', [ expression ], ';';

(* 2.4 External definiitions *)
translation-unit
    = external-declaration
    | translation-unit, external-declaration;

external-declaration
    = function-definition
    | declaration;

function-definition
    = [ attribute-specifier-sequence ], declaration-specifiers, declarator, function-body;

function-body
    = compound-statement;

(* 3 Preprocessing directives *)
preprocessing-file
    = [ group ];

group
    = group-part
    | group, group-part;

group-part
    = if-section
    | control-line
    | text-line
    | '#', non-directive;

if-section
    = if-group, [ elif-groups ], [ else-group ], endif-line;

if-group
    = '#', 'if', constant-expression, new-line, [ group ]
    | '#', 'ifdef', identifier, new-line, [ group ]
    | '#', 'ifndef', identifier, new-line, [ group ];

elif-groups
    = elif-group
    | elif-groups, elif-group;

elif-group
    = '#', 'elif', constant-expression, new-line, [ group ]
    | '#', 'elifdef', identifier, new-line, [ group ]
    | '#', 'elifndef', identifier, new-line, [ group ];

else-group
    = '#', 'else', new-line, [ group ];

endif-line
    = '#', 'endif', new-line;

control-line
    = '#', 'include', pp-tokens, new-line
    | '#', 'embed', pp-tokens, new-line
    | '#', 'define', identifier, replacement-list, new-line
    | '#', 'define', identifier, lparen, [ identifier-list ], ')', replacement-list, new-line
    | '#', 'define', identifier, lparen, '...', ')', replacement-list, new-line
    | '#', 'define', identifier, lparen, identifier-list, ',', '...', ')', replacement-list, new-line
    | '#', 'undef', identifier, new-line
    | '#', 'line', pp-tokens, new-line
    | '#', 'error', [ pp-tokens ], new-line
    | '#', 'warning', [ pp-tokens ], new-line
    | '#', 'pragma', [ pp-tokens ], new-line
    | '#', new-line;

text-line
    = [ pp-tokens ], new-line;

non-directive
    = pp-tokens, new-line;

lparen
    = ? a '(' character not immediately preceded by white space ?;

replacement-list
    = [ pp-tokens ];

pp-tokens
    = preprocessing-token
    | pp-tokens, preprocessing-token;

new-line
    = ? the new-line character ?;

identifier-list
    = identifier
    | identifier-list, ',', identifier;

pp-parameter
    = pp-parameter-name, [ pp-parameter-clause ];

pp-parameter-name
    = pp-standard-parameter
    | pp-prefixed-parameter;

pp-standard-parameter
    = identifier;

pp-prefixed-parameter
    = identifier, '::', identifier;

pp-parameter-clause
    = '(', [ pp-balanced-token-sequence ], ')';

pp-balanced-token-sequence
    = pp-balanced-token
    | pp-balanced-token-sequence, pp-balanced-token;

pp-balanced-token
    = '(', [ pp-balanced-token-sequence ], ')'
    | '[', [ pp-balanced-token-sequence ], ']'
    | '{', [ pp-balanced-token-sequence ], '}'
    | ? any pp-token other than a parenthesis , a bracket , or a brace ?;

embed-parameter-sequence
    = pp-parameter
    | embed-parameter-sequence, pp-parameter;

defined-macro-expression
    = 'defined', identifier
    | 'defined', '(', identifier, ')';

h-preprocessing-token
    = ? any preprocessing-token other than > ?;

h-pp-tokens
    = h-preprocessing-token
    | h-pp-tokens, h-preprocessing-token;

header-name-tokens
    = string-literal
    | '<', h-pp-tokens, '>';

has-include-expression
    = '__has_include', '(', header-name, ')'
    | '__has_include', '(', header-name-tokens, ')';

has-embed-expression
    = '__has_embed', '(', header-name, [ embed-parameter-sequence ], ')'
    | '__has_embed', '(', header-name-tokens, [ pp-balanced-token-sequence ], ')';

has-c-attribute-express
    = '__has_c_attribute', '(', pp-tokens, ')';

va-opt-replacement
    = '__VA_OPT__', '(', [ pp-tokens ], ')';

standard-pragma
    = '#', 'pragma', 'STDC', 'FP_CONTRACT', on-off-switch
    | '#', 'pragma', 'STDC', 'FENV_ACCESS', on-off-switch
    | '#', 'pragma', 'STDC', 'FENV_DEC_ROUND', dec-direction
    | '#', 'pragma', 'STDC', 'FENV_ROUND', direction
    | '#', 'pragma', 'STDC', 'CX_LIMITED_RANGE', on-off-switch;

on-off-switch
    = 'ON'
    | 'OFF'
    | 'DEFAULT';

direction
    = 'FE_DOWNWARD'
    | 'FE_TONEAREST'
    | 'FE_TONEARESTFROMZERO'
    | 'FE_TOWARDZERO'
    | 'FE_UPWARD'
    | 'FE_DYNAMIC';

dec-direction
    = 'FE_DEC_DOWNWARD'
    | 'FE_DEC_TONEAREST'
    | 'FE_DEC_TONEARESTFROMZERO'
    | 'FE_DEC_TOWARDZERO'
    | 'FE_DEC_UPWARD'
    | 'FE_DEC_DYNAMIC';

(* 4 Floating-point subject sequence *)
(* 4.1 NaN char sequence *)
n-char-sequence
    = digit
    | nondigit
    | n-char-sequence, digit
    | n-char-sequence, nondigit;

(* 4.2 NaN wchar_t sequence *)
n-wchar-sequence
    = digit
    | nondigit
    | n-wchar-sequence, digit
    | n-wchar-sequence, nondigit;

(* 5 Decimal floating-point subject sequence *)
(* 5.1 NaN decimal char sequence *)
d-char-sequence
    = digit
    | nondigit
    | d-char-sequence, digit
    | d-char-sequence, nondigit;

(* 5.2 NaN decimal wchar_t sequence *)
d-wchar-sequence
    = digit
    | nondigit
    | d-wchar-sequence, digit
    | d-wchar-sequence, nondigit;
